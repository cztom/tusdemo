/**
 * Minified by jsDelivr using Terser v5.15.1.
 * Original file: /npm/tus-js-client@3.0.1/lib/node/sources/StreamSource.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
async function readChunk(e,t){return new Promise(((s,r)=>{const o=t=>{e.off("readable",i),r(t)},i=()=>{const r=e.read(t);null!==r&&(e.off("error",o),e.off("readable",i),s(r))};e.once("error",o),e.on("readable",i)}))}export default class StreamSource{constructor(e){this._stream=e,this.size=null,this._buf=Buffer.alloc(0),this._bufPos=0,this._ended=!1,this._error=null,e.pause(),e.on("end",(()=>{this._ended=!0})),e.on("error",(e=>{this._error=e}))}async slice(e,t){if(e<this._bufPos)throw new Error("cannot slice from position which we already seeked away");if(e>this._bufPos+this._buf.length)throw new Error("slice start is outside of buffer (currently not implemented)");if(this._error)throw this._error;let s;if(e<this._bufPos+this._buf.length){const r=e-this._bufPos,o=Math.min(this._buf.length,t-this._bufPos);s=this._buf.slice(r,o)}else s=Buffer.alloc(0);if(this._ended)return s.size=s.length,{value:s,done:!0};const r=t-e;if(r>s.length){const e=await readChunk(this._stream,r-s.length);s=Buffer.concat([s,e])}return this._buf=s,this._bufPos=e,s.size=s.length,{value:s,done:this._ended}}close(){this._stream.destroy()}}
//# sourceMappingURL=/sm/4543456a7231a3ab38314a1fc3a47f5d1584a0efe9eeb223bc69c74951ac3c94.map